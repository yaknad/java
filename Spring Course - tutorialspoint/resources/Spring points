Points:
*******
Core Container: Core, Beans, Context, SpeL
Data Access/Integration: JDBC, ORM, OXM (xml), JMS, Transaction
Web: Web, Web-MVC, Web-Socket, Web-Portlet
Miscellaneous modules: AOP, Aspects, Instrumentation, Messaging, Test 



Beans xml tags:
***************
file root:
<beans  default-init-method=,default-destroy-method= ></beans> 

bean declaration (+ property assign):
<bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld", parent, abstract, scope, name, init, destroy>
  <property name = "message" value = "Hello World!"/>
</bean>

attributes: 
class, 
name, 
scope: singleton (default), prototype, request, session, global-session ,
parent: enables beans definition inheritance (value is the id / name of another bean - the parent) ,
abstract: define a bean as a template to be used as parent by other beans,
constructor-arg,
property,
property.ref: assign a beans' property with a reference to another bean,
autowire: sets the autowiring mode - see the autowire section in the Dependency Injection chapter,
lazy-initialization mode: tells the IoC container to create a bean instance when it is first requested, rather than at the startup.
init-method: A callback to be called just after all necessary properties on the bean have been set by the container. Either this
					   or the bean can implement the InitializingBean interface, and then the afterPropertiesSet() will be called without using this attribute.
default-init-method: same as "init-method" to be used globally (in the <beans> object).
destroy-method: A callback to be used when the container containing the bean is destroyed.  Either this 
					or the bean can implement the DisposableBean interface, and then the destroy() will be called without using this attribute.
					This requires the using of the registerShutdownHook() method of the AbstractApplicationContext.
default-destroy-method: same as "destroy-method" to be used globally (in the <beans> object).


Dependency Injection:
*********************
Setter based:
-------------
<bean ...>
	<property name = "field1" ref = "another bean name to be injected in here"/>
	<property name = "field2" value = "a primitive value or a simple boxed value"/>
</bean>	
or:
adding the namespace xmlns:p = "http://www.springframework.org/schema/p": 
<bean id = "x" class = "xyz" p:field1-ref = "another bean name" p:field2 = "simple value"/>
</bean>

Constructor based:
------------------
<bean ...>
      <constructor-arg ref = "bean name for first constructor param"/>
      <constructor-arg value = "simple value for second constructor param"/>
</bean>
or with explicit ordering:
<bean ...>
      <constructor-arg index="0" ref = "bean name for first constructor param"/>
      <constructor-arg index="1" value = "simple value for second constructor param"/>
</bean>
or with explicit type matching:
<bean ...>
      <constructor-arg type = "com.MyClass" ref = "bean name for first constructor param"/>
      <constructor-arg type = "int" value = "simple value for second constructor param"/>
</bean>

Inner bean (accessible only inside the outer bean):
<bean id = "x" class = "com.FirstClass">
      <property name = "prop">
         <bean id = "y" class = "com.SecondBean"/>   - instead of referencing another "outer" bean
      </property>
</bean>

Injected collections:
<list> - list of values, allowing duplicates.
<set> - set of values but without any duplicates.
<map> - collection of name-value pairs where name and value can be of any type.
<props> - a collection of name-value pairs where the name and value are both Strings.
for example:
<bean>
	  <property name = "someMapProperty">
         <map>
            <entry key = "1" value = "Hello"/>
            <entry key = "2" value = "World"/>
            <entry key = "3" value-ref = "reference to another bean"/>
         </map>
      </property>
</bean>

Injecting Null values (see more examples of nulls and empty strings in the demo application):
<bean id = "..." class = "...">
   <property name = "propName"><null/></property>
</bean>


Autowiring (autowire relationships between collaborating beans without using <constructor-arg> and <property> elements)
-----------
(Two options to trigger it: A. by xml - using the autowire attribute in the bean declaration. B. by annotations - see in "annotations" section)
advantage over regular DI - reduce the need to specify properties or constructor arguments in xml.
disadvantages - Cannot autowire simple properties such as primitives, Strings, and Classes.
				Autowiring is less exact than explicit wiring, so if possible prefer using explicit wiring.
				You can still specify dependencies using <constructor-arg> and <property> settings which will always override autowiring.

modes (set by the "autowire" attribute of the bean. Only when using the autowire attribute. When using annotations there's a unique behavoir
	   to each annotation - see in the annotations section.):
no - default. no autowiring. use explicit wiring (Constructor or Setter based - like seen before).
byName - for properties of the beans on which autowire attribute is set to "byName" in the XML file, 
		 it tries to match and wire its properties with the beans defined by the same names in the configuration file.
byType - tries to match and wire a property if its type matches with exactly one of the bean names (? - should be: type names) in configuration file. 
		 If more than one such beans exists, a fatal exception is thrown.
constructor - same as "byType"(!) but injected as constructor-arg (e.g. when already using one explicit "constructor-arg" param,
			  Spring will know it should use a constructor args injection, and use automatic injection for the other constructor param.)
autodetect - first tries to autowire using "constructor" and not possible, uses "byType". 
 
Java based Configuration
************************
See Annotations: @Configuration, @Bean
Uses a class annotated with @Configuration as a source of bean definitions. 
This can be used with the AnnotationConfigApplicationContext class to retrieve this beans (NO NEED FOR XML FILE!). 
It may use multiple config classes. When using the @Reuqired annotation (see in Annotations) , only the main configuration file should be 
used when instantiating the AnnotationConfigApplicationContext class (see below).
The method name that is annotated with @Bean works as bean ID and it creates and returns the actual bean. 

AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigClass.class);
ctx.register(AppConfig.class, OtherConfig.class);
...
MyService myService = ctx.getBean(MyService.class); (ConfigClass has a "public MyService myService()" method).

Beans dependency:
@Configuration
public class TextEditorConfig {
   @Bean 
   public TextEditor textEditor(){
      return new TextEditor( spellChecker() );
   }
   @Bean 
   public SpellChecker spellChecker(){
      return new SpellChecker( );
   }
}

Annotations:
************
Annotation injection is performed before XML injection. Thus, the latter configuration will override the former for properties wired through both approaches.
Add to configuration xml file: <context:annotation-config/>. You should still declare beans in the xml file 
(the annotations replace some of the features we used in the xml before - but not all)
@Required: applies to bean property setter methods and it indicates that the affected bean property must be populated in XML configuration file 
		   at configuration time. Otherwise, the container throws a BeanInitializationException exception.
@Autowired: on Setter Methods: to get rid of the <property> element in XML configuration file. When Spring finds an @Autowired 
						annotation used with setter methods, it tries to perform *byType* autowiring on the method. (see @Resource annotation.)
			on Properties: to get rid of the setter methods. When you will pass values of autowired properties using <property> Spring will automatically 
						assign those properties with the passed values or references. (*byType* autowiring.)
			on Constructors: indicates that the constructor should be autowired when creating the bean, even if no <constructor-arg> elements 
						are used while configuring the bean in XML file. (*byType* autowiring.)
			with (required=false) option: By default, the @Autowired annotation implies the dependency is required similar to @Required annotation, 
						however, you can turn off the default behavior by using (required=false) option with @Autowired. (*byType* autowiring.)
@PostConstruct: an alternate of the "init-method" attribute.
@PreDestroy: an alternate of the "destroy-method" attribute. (still needs registerShutdownHook())
@Resource: on fields or setter methods. Takes a 'name' attribute which will be interpreted as the bean name to be injected. 
		   It follows by-name autowiring semantics - as opposed to @Autowired annotation that acts byType.
		   If no 'name' is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; 
		   in case of a setter method, it takes the bean property name.
@Qualifier: when you create more than one bean of the same type and want to wire only one of them with a property. (to be used together with @Autowired)		   
@Configuration: indicates that the class can be used by the Spring IoC container as a source of bean definitions.
@Bean: a method annotated with @Bean will return an object that should be registered as a bean in the 
	  Spring application context (via annotations or xml). Properties of this annotations: (initMethod = "init", destroyMethod = "cleanup" )
@Import: in Java script configuration, allows for loading @Bean definitions from another configuration class.
@Scope: defines the beans scope in a Java configuration class. Use it - @Scope("prototype").

Context types (IoC Containers):
*******************************
ApplicationContext - abstract
AbstractApplicationContext - abstract
FileSystemXmlApplicationContext - Loads the beans config from an XML file. Need to provide the full path of the XML to the constructor.
ClassPathXmlApplicationContext  - loads the beans config from an XML file. No need to provide the FULL path of the XML file but you need to set the CLASSPATH properly because this container will look like bean configuration XML file in CLASSPATH.
WebXmlApplicationContext − loads beans config XML file from within a web application.
AnnotationConfigApplicationContext - reads configuration from Annotations - Java based configuration. Reads configuration from Java code.
BeanFactory - the simplest container providing the basic support for DI (and also: BeanFactoryAware, InitializingBean, DisposableBean).
It still exists for backward compatibility. Use ApplicationContext instead.
AnnotationConfigApplicationContext

Useful Interfaces:
******************
InitializingBean (see above)
DisposableBean (see above)
BeanPostProcessor: defines callback methods to run before/after the Spring container finishes initializing a bean. You may create some of these and control
				   their order of calling by implementing the Ordered interface. You should register these BeanPostProcessors as beans. 
				   An ApplicationContext automatically detects any beans that are defined with the implementation of the BeanPostProcessor interface 
				   and registers these beans as postprocessors. The "after init" method needs the AbstractApplicationContext.registerShutdownHook() to run.
				   The "before init" method will run before the method that is registered in the bean's init-method attribute.
				   The "after init" method will run after the method that is registered in the bean's init-method attribute.
Ordered: see BeanPostProcessor.			   
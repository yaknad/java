Points:
*******
Core Container: Core, Beans, Context, SpeL
Data Access/Integration: JDBC, ORM, OXM (xml), JMS, Transaction
Web: Web, Web-MVC, Web-Socket, Web-Portlet
Miscellaneous modules: AOP, Aspects, Instrumentation, Messaging, Test 



Beans xml tags:
***************
file root:
<beans  default-init-method=,default-destroy-method= ></beans> 

bean declaration (+ property assign):
<bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld", parent, abstract, scope, name, init, destroy>
  <property name = "message" value = "Hello World!"/>
</bean>

attributes: 
class, 
name, 
scope: singleton (default), prototype, request, session, global-session ,
parent: enables beans definition inheritance (value is the id / name of another bean - the parent) ,
abstract: define a bean as a template to be used as parent by other beans,
constructor-arg,
property.ref: assign a beans' property with a reference to another bean,
autowire: sets the autowiring mode - see the autowire section in the Dependency Injection chapter,
lazy-initialization mode: tells the IoC container to create a bean instance when it is first requested, rather than at the startup.
init-method: A callback to be called just after all necessary properties on the bean have been set by the container. Either this
					   or the bean can implement the InitializingBean interface, and then the afterPropertiesSet() will be called without using this attribute.
default-init-method: same as "init-method" to be used globally (in the <beans> object).
destroy-method: A callback to be used when the container containing the bean is destroyed.  Either this 
					or the bean can implement the DisposableBean interface, and then the destroy() will be called without using this attribute.
					This requires the using of the registerShutdownHook() method of the AbstractApplicationContext.
default-destroy-method: same as "destroy-method" to be used globally (in the <beans> object).


Dependency Injection:
*********************
Setter based:
-------------
<bean ...>
	<property name = "field1" ref = "another bean name to be injected in here"/>
	<property name = "field2" value = "a primitive value or a simple boxed value"/>
</bean>	
or:
adding the namespace xmlns:p = "http://www.springframework.org/schema/p": 
<bean id = "x" class = "xyz" p:field1-ref = "another bean name" p:field2 = "simple value"/>
</bean>

Constructor based:
------------------
<bean ...>
      <constructor-arg ref = "bean name for first constructor param"/>
      <constructor-arg value = "simple value for second constructor param"/>
</bean>
or with explicit ordering:
<bean ...>
      <constructor-arg index="0" ref = "bean name for first constructor param"/>
      <constructor-arg index="1" value = "simple value for second constructor param"/>
</bean>
or with explicit type matching:
<bean ...>
      <constructor-arg type = "com.MyClass" ref = "bean name for first constructor param"/>
      <constructor-arg type = "int" value = "simple value for second constructor param"/>
</bean>

Inner bean (accessible only inside the outer bean):
<bean id = "x" class = "com.FirstClass">
      <property name = "prop">
         <bean id = "y" class = "com.SecondBean"/>   - instead of referencing another "outer" bean
      </property>
</bean>

Injected collections:
<list> - list of values, allowing duplicates.
<set> - set of values but without any duplicates.
<map> - collection of name-value pairs where name and value can be of any type.
<props> - a collection of name-value pairs where the name and value are both Strings.
for example:
<bean>
	  <property name = "someMapProperty">
         <map>
            <entry key = "1" value = "Hello"/>
            <entry key = "2" value = "World"/>
            <entry key = "3" value-ref = "reference to another bean"/>
         </map>
      </property>
</bean>

Injecting Null values (see more examples of nulls and empty strings in the demo application):
<bean id = "..." class = "...">
   <property name = "propName"><null/></property>
</bean>


Autowiring (both by xml - using the autowire attribute in the bean declaration, or by annotations)
-----------
advantage or regular DI - reduce the need to specify properties or constructor arguments
disadvantages - Cannot autowire simple properties such as primitives, Strings, and Classes.
				Autowiring is less exact than explicit wiring, so if possible prefer using explict wiring.
				You can still specify dependencies using <constructor-arg> and <property> settings which will always override autowiring.

modes (set by the "autowire" attribute of the bean):
no - default. no autowiring. use explicit wiring (Constructor or Setter based - like seen before).
byName - for properties of the beans on which autowire attribute is set to "byName" in the XML file, 
		 it tries to match and wire its properties with the beans defined by the same names in the configuration file.
byType - tries to match and wire a property if its type matches with exactly one of the bean names (? - should be: type names) in configuration file. 
		 If more than one such beans exists, a fatal exception is thrown.
constructor - same as "byType"(!) but injected as constructor-arg (e.g. when already using one explicit "constructor-arg" param,
			  Spring will know it should use a constructor args injection, and use automatic injection for the other constructor param
autodetect - first tries to autowire using "constructor" and not possible, uses "byType". 
 
Annotations:
************





Context types (IoC Containers):
*******************************
ApplicationContext - abstract
AbstractApplicationContext - abstract
FileSystemXmlApplicationContext - Loads the beans config from an XML file. Need to provide the full path of the XML to the constructor.
ClassPathXmlApplicationContext  - loads the beans config from an XML file. No need to provide the FULL path of the XML file but you need to set the CLASSPATH properly because this container will look like bean configuration XML file in CLASSPATH.
WebXmlApplicationContext âˆ’ loads beans config XML file from within a web application.
AnnotationConfigApplicationContext - reads configuration from Annotations - Java based configuration (+ Beans configuration xml file??? ),
.... - reads configuration from Java code ( + ????)
BeanFactory - the simplest container providing the basic support for DI (and also: BeanFactoryAware, InitializingBean, DisposableBean).
It still exists for backward compatibility. Use ApplicationContext instead.


Useful Interfaces:
******************
InitializingBean (see above)
DisposableBean (see above)
BeanPostProcessor: defines callback methods to run before/after the Spring container finishes initializing a bean. You may create some of these and control
				   their order of calling by implementing the Ordered interface. You should register these BeanPostProcessors as beans. 
				   An ApplicationContext automatically detects any beans that are defined with the implementation of the BeanPostProcessor interface 
				   and registers these beans as postprocessors. The "after init" method needs the AbstractApplicationContext.registerShutdownHook() to run.
				   The "before init" method will run before the method that is registered in the bean's init-method attribute.
				   The "after init" method will run after the method that is registered in the bean's init-method attribute.
Ordered: see BeanPostProcessor.			   